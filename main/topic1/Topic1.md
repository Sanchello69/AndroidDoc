# Generics

> Согласно официальной документации:
> 
> Обобщения — это классы, структуры, интерфейсы и методы, имеющие плейсхолдеры (параметры типов) для одного или более хранимых или применяемых типов. Класс обобщенной коллекции может использовать параметр типа как плейсхолдер для типа хранимых в нем объектов. Параметры типа выступают как типы его полей и типы параметров методов. Обобщенный метод может задействовать свой параметр типа как тип возвращаемого значения или как тип одного из его формальных параметров.

Если коротко, то Generics — это гибкая система, позволяющая работать с любыми типами данных. Она снимает с вас все заботы о типах и поручает их компилятору.

Cвойство функции, позволяющее обрабатывать значения разных типов одним способом (используя один алгоритм), называется параметрическим полиморфизмом. То есть дженерики это реализация параметрического полиморфизма в Kotlin.

```kotlin
interface MyInterface<T> {
    fun getList() : List<T>
}

class MyClass<T>(private val list: List<T>): MyInterface<T>{
    override fun getList(): List<T> = list
}

fun <E> MyClass<E>.getFirstItem() : E = this.getList()[0]
```

## Type Erasure

Так как Kotlin тесно связан с Java, мы сталкиваемся с затиранием типов (Type Erasure).
Компилятор стирает информацию о типе, заменяя все параметры без ограничений (unbounded) типом Object, а параметры с границами (bounded) — на эти границы.
Кроме стирания типов, компилятор может добавлять приведение (cast) к нужному типу и создавать переходные bridge-методы, чтобы сохранить полиморфизм в классах-наследниках.

Вот так будет выглядеть наш верхний пример в байт-коде Java:

```java
public interface MyInterface {
   @NotNull
   List getList();
}

public final class MyClass implements MyInterface {
   private final List list;

   @NotNull
   public List getList() {
      return this.list;
   }

   public MyClass(@NotNull List list) {
      Intrinsics.checkNotNullParameter(list, "list");
      super();
      this.list = list;
   }
}

public static final Object getFirstItem(@NotNull MyClass $this$getFirstItem) {
      Intrinsics.checkNotNullParameter($this$getFirstItem, "$this$getFirstItem");
      return $this$getFirstItem.getList().get(0);
   }
```

Получается в Java и Kotlin по итогу будет один класс (в отличие к примеру от C++, где для каждого типа будет свой класс), где общий тип будет просто заменен на верхнюю границу.

Получается, что из полезного с T можно делать следующее:
- использовать как тип
- использовать в as (получится, потому что вместо t as T подставится t as Any?, а это проверка всегда пройдет)

```kotlin
fun main() {
    println(example<String>(5))
}

fun <E> example(x: Int) {
    val y = x as E
    println(y)
}
```

Нельзя делать с T:
- создавать новые объекты
- проверять на is
- использовать в companion object

Многие недостатки решает модификатор inline, но это в другой раз)).

## Compile-time safety

Система типов проверяет дженерики на этапе компиляции. Если не использовать небезопасные операции, во время выполнения все будет хорошо.

<p align="center">
  <img height="300" src="https://github.com/Sanchello69/AndroidDoc/blob/main/main/topic1/res/kotlin_type_system.png">
</p>

Далее мы сталкиваемся с таким понятием как вариантность.

```kotlin
val strs = mutableListOf<String>()
val objs: MutableList<Any> = strs
```

Этот код не выполнится, так как дженерики в Kotlin инвариантны по умолчанию.

**Инвариантность — отсутствие наследования между производными типами.**

Если Кошка — это подтип Животные, то Множество<Кошки> не является подтипом Множество<Животные> и Множество<Животные> не является подтипом Множество<Кошки>.

List<Int> никак не соотносится с List<Any>, так как лист является дженериком.
    
**Ковариантность — это сохранение иерархии наследования исходных типов в производных типах в том же порядке.**

Например, если Кошка — это подтип Животные, то Множество<Кошки> — это подтип Множество<Животные>. Следовательно, с учетом принципа подстановки можно выполнить такое присваивание:

Множество<Животные>  = Множество<Кошки>
    
Система типов в Kotlin ковариантна, следовательно мы можем, например, выполнить val obj: Any = 5. Аргументы функции также являются ковариантными.
    
Возвращаемое значение функции находится в контравариантной позиции.
    
**Контравариантность — это обращение иерархии исходных типов на противоположную в производных типах.**
    
Например, если Кошка — это подтип Животные, то Множество<Животные> — это подтип Множество<Кошки>. Следовательно,  с учетом принципа подстановки можно выполнить такое присваивание:

Множество<Кошки> = Множество<Животные>
    
Следующий код выполнится:
    
```kotlin
fun main() {
    check(B())
}

open class A(){}

class B(): A(){}

fun check(obj: A){}
```
    
